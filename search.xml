<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap源码阅读</title>
    <url>/2022/03/27/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="HashMap-源码阅读"><a href="#HashMap-源码阅读" class="headerlink" title="HashMap 源码阅读"></a>HashMap 源码阅读</h1><h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，实现了基于哈希表的 Map 接口，非线程安全。</p>
<p>HashMap 可以存放 null 的 key 和 null 值，但 null 作为 key 只能有一个，null 作为 value 可以有多个。</p>
<p>HashMap 有两个版本：</p>
<ul>
<li>JDK8之前，HashMap 的底层数据结构为数组 + 链表，数组是 HashMap 的主体，链表则是为解决哈希冲突而存在的。</li>
<li>JDK8之后，HashMap 的底层数据结构为数组 + 链表&#x2F;红黑树，当链表长度大于阈值（默认是8）并且数组容量大于64时，将链表转换为红黑树，以减少搜索时间。</li>
</ul>
<p>HashMap 的默认大小为16，之后每次扩充，容量都变为原来的2倍，并且 HashMap 总是以2的幂作为哈希表的大小</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>loadFactor</code>被称为负载因子，其默认大小为0.75f</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="关于负载因子"><a href="#关于负载因子" class="headerlink" title="关于负载因子"></a>关于负载因子</h2><p>在分析构造函数时，我们提到了负载因子的默认大小为0.75，所以为什么为0.75，而不是1或者0.5呢？</p>
<p>首先要知道 loadFactor 的作用：</p>
<p>loadFactor 负载因子用来控制数组存放数据的疏密程度</p>
<ul>
<li><p>负载因子越大（越趋近于1），那么数组存放的数据也就越多，链表长度就会增加，<strong>会导致查找开销大，效率低</strong>。</p>
</li>
<li><p>负载因子越小（越趋近于0），那么数组存放的数据也就越少，存放数据很分散，<strong>导致数组利用率低，会频繁扩容非常消耗性能</strong>。</p>
</li>
</ul>
<blockquote>
<p>loadFactor 与 threshold</p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</blockquote>
<p>作为一般规则，默认负载因子 (.75) 在时间和空间成本之间提供了良好的折衷。较高的值会减少空间开销，但会增加查找成本（反映在 HashMap 类的大多数操作中，包括 get 和 put）。在设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以尽量减少重新哈希操作的次数。如果初始容量大于最大条目数除以负载因子，则不会发生重新哈希操作。</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="putMapEntries-方法："><a href="#putMapEntries-方法：" class="headerlink" title="putMapEntries 方法："></a><strong>putMapEntries 方法：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h3><p>HashMap 对外只提供put() 方法用于添加元素，put() 方法内部调用的是putVal() 方法</p>
<p><strong>putVal() 方法的流程如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素就直接插入</li>
<li>如果定位到的数组位置有元素就和要插入的 key 作比较，如果 key 相同就直接覆盖，如果 key 不同，就判断p是否为一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入，如果是链表节点，则遍历到链表尾部插入。</li>
</ol>
<p><img src="/images/put%E6%B5%81%E7%A8%8B.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//hash(key)：获取key的hash值，当key为null时，哈希值为0</span></span><br><span class="line">    <span class="comment">//key，value：要存储的键值对</span></span><br><span class="line">    <span class="comment">//第四个参数为onlyIfAbsent，默认是false，如果是true表示，如果不存在改key就进行put操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// （第一次put操作）table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="comment">//第一次resize()扩容操作后，数组容量会初始化为16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; </span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中</span></span><br><span class="line">    <span class="comment">// 桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e为辅助节点，用来记录key值与新插入节点相同的旧节点</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值相等，key不相等；</span></span><br><span class="line">        <span class="comment">// 为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JDK7的 put( ) 方法</strong></p>
<ul>
<li><p>如果定位到的数组位置没有元素 就直接插入。</p>
</li>
<li><p>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</p>
</li>
</ul>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get( ) 方法"></a>get( ) 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize( ) 方法"></a>resize( ) 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//旧数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//旧数组阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//新数组的容量和阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="comment">// MAXIMUM_CAPACITY = 1&lt;&lt;30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，容量和阈值都扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//oldCap = 0  未初始化</span></span><br><span class="line">    <span class="comment">//当使用new HashMap&lt;&gt;(int initalCapacity)时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//当使用new HashMap&lt;&gt;()时</span></span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果为初始化数组，那么到这里已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//当该数组下标j位置只有一个元素时，直接迁移这个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//计算此元素在新数组的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果e为红黑树节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//红黑树节点迁移</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//e为链表节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="comment">// 不需要换桶</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 需要换桶</span></span><br><span class="line">                        <span class="comment">// 新桶位置 = 旧桶位置+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 数据结构</title>
    <url>/2022/04/01/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis-底层数据结构"><a href="#Redis-底层数据结构" class="headerlink" title="Redis 底层数据结构"></a>Redis 底层数据结构</h1><p><img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_13-02-14.png"></p>
<h2 id="Redis-的键和值用什么结构组织的呢？"><a href="#Redis-的键和值用什么结构组织的呢？" class="headerlink" title="Redis 的键和值用什么结构组织的呢？"></a>Redis 的键和值用什么结构组织的呢？</h2><p>为了实现键和值的快速访问，Redis 采用了一个哈希表来存储所有的键值对。一个哈希表就是一个数组，数组的每个元素称为一个哈希桶。哈<strong>希桶中保存的并不是数据本身，而是指向具体值的指针</strong>。所以不管是 String 还是集合，哈希桶的元素都是指向他们的指针。</p>
<p><img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_13-12-47.png"></p>
<h2 id="Redis-的-rehash操作"><a href="#Redis-的-rehash操作" class="headerlink" title="Redis 的 rehash操作"></a>Redis 的 rehash操作</h2><p>虽然 Redis 使用拉链法解决哈希冲突，但是随着哈希冲突越来越多，会导致拉链过长，进而导致这条链上的元素过多，增加查找耗时。所以 Redis 会对哈希表进行 rehash 操作来增加现有的哈希桶的数量。</p>
<p>为了使 rehash 操作更高效，redis 使用了两个全局哈希表，一开始插入数据时，只向哈希表1插入数据，对哈希表2不做操作，，随着数据不断增多，Redis 开始执行 rehash 操作，可以分为3步：</p>
<ol>
<li>给哈希表2分配更大的空间，如哈希表1的二倍。</li>
<li>把哈希表1的数据重新映射并拷贝到哈希表2。</li>
<li>释放哈希表1的空间，留作下一次 rehash 使用。</li>
</ol>
<blockquote>
<p><strong>渐进式 rehash</strong></p>
<p>为了避免一次性拷贝大量数据造成 Redis 线程阻塞，Redis 采用渐进式 rehash</p>
<p>简单来说就是在拷贝数据时，Redis 正常处理客户端请求，每处理一个请求时，从哈希表 1 中的一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置。</p>
</blockquote>
<h2 id="集合类型的底层数据结构"><a href="#集合类型的底层数据结构" class="headerlink" title="集合类型的底层数据结构"></a>集合类型的底层数据结构</h2><p>集合类型的底层数据结构有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p><img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_13-53-34.png"></p>
<p>压缩列表类似于数组，数组中的每一个元素都对应了一个数据，不过和数组不同的是，压缩列表在压缩列表的表头增加了三个字段：zlbytes、zltail和zllen。在列表的尾部增加了 zlend 字段。</p>
<blockquote>
<p>zlbytes：列表长度</p>
<p>zltail：列表尾的偏移量</p>
<p>zllend：列表中 entry 的数量</p>
<p>zlend：表示列表结束</p>
</blockquote>
<p>压缩列表查找列表第一个元素和最后一个元素的时间复杂度为<code>O(1)</code>，查找其他元素则为<code>O(N)</code></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表，<strong>跳表是在链表的基础上增加了多级索引，通过索引位置的几个跳转实现数据的快速定位。</strong></p>
<p><img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_14-09-43.png"></p>
<blockquote>
<p>如果我们在链表中查找 33 这个元素，只能从头开始遍历这个链表，查找 6 次，直到可以找到 33 这个元素，时间复杂度为 <code>O(N)</code>。</p>
<p>为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就能定位到元素 33 了。</p>
<p>如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。</p>
<p>可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 <code>O(logN)</code>。</p>
</blockquote>
<h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><p><img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_14-23-22.png"></p>
<h2 id="为什么-String-类型内存开销大"><a href="#为什么-String-类型内存开销大" class="headerlink" title="为什么 String 类型内存开销大"></a>为什么 String 类型内存开销大</h2><p>String 类型除了记录实际数据外，还需要额外的内存空间记录数据长度、空间使用等信息，这些信息叫做元数据。</p>
<h3 id="简单动态字符串-SDS-（Simple-Dynamic-String）"><a href="#简单动态字符串-SDS-（Simple-Dynamic-String）" class="headerlink" title="简单动态字符串 SDS （Simple Dynamic String）"></a>简单动态字符串 SDS （Simple Dynamic String）</h3><p>当 String 类型保存的数据为字符时，String 就会用 SDS 结构体来保存数据。</p>
<img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_16-39-05.png" style="zoom:20%;" />

<blockquote>
<p><strong>buf</strong>：字节数组，保存实际数据。为了表示字节数组的结束，在数组最后加上<code>\0</code>表示数组结束，占用一个字节</p>
<p><strong>len：</strong>占4个字节，表示 buf 的已用长度。</p>
<p><strong>alloc：</strong>占4个字节，表示 buf 的实际分配长度，一般大于 len</p>
</blockquote>
<h3 id="RedisObject-结构体"><a href="#RedisObject-结构体" class="headerlink" title="RedisObject 结构体"></a>RedisObject 结构体</h3><p>redis 的数据类型有很多，而且，不同的数据类型有些相同的元数据要记录（比如说最后一次访问的时间、被引用的次数等），因此 Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p>
<img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_16-47-58.png" style="zoom:33%;" />

<h3 id="String-类型是怎么保存数据的呢？"><a href="#String-类型是怎么保存数据的呢？" class="headerlink" title="String 类型是怎么保存数据的呢？"></a>String 类型是怎么保存数据的呢？</h3><p>三种编码方式：</p>
<ol>
<li>当保存64位有符号整数时，<strong>String 类型会把它保存为一个 8 字节的 Long 类型的整数</strong>，这种保存方式通常叫做 int 编码方式</li>
<li>当保存的是字符串数据，并且字符串小<strong>于等于44字节</strong>的时候，<strong>RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域</strong>，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式。</li>
<li>当字符串<strong>大于 44 字节</strong>的时候，SDS 数据量就开始变多，Redis 就不再把 RedisObject 和 SDS 放在一起了，而是<strong>会给 SDS 分配独立的内存区域，并用指针指向 SDS 结构</strong>。这种布局方式被称为 raw 编码模式。</li>
</ol>
<p><img src="http://heucommunity.club/JavaBlog/Snipaste_2022-03-23_16-34-51.png"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>sychronized原理</title>
    <url>/2022/03/27/sychronized%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p>我们先来看一下什么是 Monitor ？</p>
<p>Monitor 被翻译成<strong>监视器</strong>或<strong>管程</strong>，每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁，那么该对象头的Mark Word 就被设置指向 Monitor 对象的指针。 </p>
<p>Monitor 的结构如下：</p>
<p><img src="/images/Monitor%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>刚开始 Monitor 的 Owner 为null</li>
<li>当 Thread-2 执行 sychronized(Obj) 时，Monitor 的 Owner 会设置为 Thread-2，Monitor 中只能有一个 Owner</li>
<li>在 Thread-2 上锁过程中，如果其他线程也来获取这个对象锁，就会进入 EntryList 阻塞</li>
<li>当 Thread-2 执行完同步代码块后，会唤醒 EntryList 中的线程来竞争锁，非公平竞争</li>
<li>WaitSet 中的 Thread-0 和 Thread-1 是之前获得过锁。</li>
</ul>
<h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h2><p>synchronized 加在<strong>同步代码</strong>块和加在<strong>方法</strong>上的原理是有一些不同的。</p>
<h3 id="同步代码块上的-synchronized"><a href="#同步代码块上的-synchronized" class="headerlink" title="同步代码块上的 synchronized"></a>同步代码块上的 synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syn</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v</code>反编译之后的字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synDemo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  </span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span>                 </span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1               </span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="number">11</span>: monitorenter           <span class="comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span></span><br><span class="line">        <span class="number">12</span>: getstatic     #<span class="number">3</span>      </span><br><span class="line">        <span class="number">15</span>: invokestatic  #<span class="number">4</span>      </span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">5</span>      </span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>      </span><br><span class="line">        <span class="number">24</span>: aload_2</span><br><span class="line">        <span class="number">25</span>: monitorexit            <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">        <span class="number">26</span>: goto          <span class="number">34</span></span><br><span class="line">        <span class="number">29</span>: astore_3</span><br><span class="line">        <span class="number">30</span>: aload_2</span><br><span class="line">        <span class="number">31</span>: monitorexit            <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">        <span class="number">32</span>: aload_3</span><br><span class="line">        <span class="number">33</span>: athrow</span><br><span class="line">        <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">12</span>    <span class="number">26</span>    <span class="number">29</span>   any</span><br><span class="line">            <span class="number">29</span>    <span class="number">32</span>    <span class="number">29</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">34</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">35</span>     <span class="number">0</span>  <span class="built_in">this</span>   LsychronizedDemo/Syn;</span><br><span class="line">            <span class="number">8</span>      <span class="number">27</span>     <span class="number">1</span>     o   Ljava/lang/Object;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">29</span></span><br><span class="line">          locals = [ <span class="keyword">class</span> <span class="title class_">sychronizedDemo</span>/Syn, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">23</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过字节码文件我们可以看到，sychronized 加在同步代码块上是通过两个指令，<code>monitorenter</code> 和 <code>monitorexit</code> 实现的。</p>
<p>每个对象都有一个 Monitor ，当 Monitor 被占用时就表示对象处于锁定状态，<code>monitorenter</code>指令就是来获取 Monitor 的所有权，<code>monitorexit</code>指令就是释放 Monitor 的所有权。这两者的工作流程如下：<br><strong>monitorenter</strong>：</p>
<ol>
<li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li>
<li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li>
<li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，直到<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li>
</ol>
<p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p>
<h3 id="同步方法上的synchronized"><a href="#同步方法上的synchronized" class="headerlink" title="同步方法上的synchronized"></a>同步方法上的synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synDemo1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v</code>反编译之后的字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synDemo1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>               </span><br><span class="line">         <span class="number">3</span>: invokestatic  #<span class="number">4</span>                 </span><br><span class="line">         <span class="number">6</span>: invokevirtual #<span class="number">5</span>                 </span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">6</span>                  </span><br><span class="line">        <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">12</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  <span class="built_in">this</span>   LsychronizedDemo/Syn;</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">23</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从字节码文件中可以看到，同步方法上的 synchronized 并没有使用<code>monitorenter</code>和<code>monitorexit</code>指令，而是在常量池中比普通方法多了<code>ACC_SYNCHRONIZED</code>标识，JVM 就根据这个标识来实现方法的同步。</p>
<p>当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p>
<h3 id="两种同步方式的区别"><a href="#两种同步方式的区别" class="headerlink" title="两种同步方式的区别"></a>两种同步方式的区别</h3><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong></p>
<p>synchronized同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。</p>
<p><strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong></p>
<h1 id="sychronized-锁优化"><a href="#sychronized-锁优化" class="headerlink" title="sychronized 锁优化"></a>sychronized 锁优化</h1><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p>
<p>对象头由以下三个部分组成：</p>
<ul>
<li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程ID、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li>
<li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li>
</ul>
<h2 id="synchronized-优化"><a href="#synchronized-优化" class="headerlink" title="synchronized 优化"></a>synchronized 优化</h2><p>上文说的 synchronized 锁原理其实说的都是<strong>重量级锁</strong>的原理那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？其实是<strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>。当锁的状态为其他状态的时候是没有用上Monitor对象的。</p>
<p>锁膨胀方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且膨胀方向不可逆。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，<strong>之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS</strong>。以后只要不发生竞争，这个对象就归该线程所有</p>
<h3 id="自旋与适应性自旋"><a href="#自旋与适应性自旋" class="headerlink" title="自旋与适应性自旋"></a>自旋与适应性自旋</h3><p><strong>自旋</strong>：当一个线程取请求某个锁的时候，这个锁正在被其他线程占用，这时此线程不会立刻进入阻塞，而是循环请求锁（自旋），<strong>自旋的目的是因为很多情况下持有锁的线程很快会释放锁，线程可以尝试一直请求锁，所以线程没有必要放弃cpu时间片，因为线程被挂起再唤醒的开销是比较大的</strong>。当然如果线程自旋一定时间还没有获得锁，仍然会被挂起。</p>
<p><strong>适应性自旋</strong>：自适应自旋是对自旋的优化，自选的时间不再固定，而是<strong>由前一次在同一个锁上的自旋时间和当前拥有锁的线程的状态决定的</strong>。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。比如下面method1经过锁粗化优化之后就和method2执行效率一样了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(test.class) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Systom.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。比如下面代码的method3和method4的执行效率是一样的，因为object锁是私有变量，不存在所得竞争关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    sychronized(obj) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁-1"><a href="#偏向锁-1" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>一句话总结它的作用：<strong>减少同一线程获取锁的代价</strong>。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。</p>
<p><strong>核心思想：</strong></p>
<p>如果一个线程获得了锁，那么锁就进入偏向模式，此时<code>Mark Word</code>的结构也就变为偏向锁结构，<strong>当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查</strong><code>Mark Word</code><strong>的锁标记位为偏向锁以及当前线程ID等于</strong><code>Mark Word</code><strong>的ThreadID即可</strong>，这样就省去了大量有关锁申请的操作</p>
<p><img src="/images/%E5%81%8F%E5%90%91%E9%94%81.png"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>应用场景：如果一个对象有多线程要加锁，但是加锁时间是错开始（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<ul>
<li>创建锁记录（Lock Record）对象，每个线程的栈帧都会包含锁记录的结构，内部可以存储锁定对象的Mark Word</li>
<li>让锁记录中的 Object Referrence 指向锁对象，并尝试 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>
<li>如果 CAS 成功，那么对象头中存储了<code>锁记录地址和状态00</code>，表示由该线程给对象加锁。  </li>
<li>如果 CAS 失败，有两种情况<ul>
<li>如果其他线程已经持有了 Object 的轻量级锁，表明有竞争，进入锁膨胀</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
<li>退出 synchronized 代码块的时候，如果锁记录为 null 则表示有锁重入，这时重置锁记录，表示重入计数减一</li>
<li>当退出 synchronized 代码块的时候锁记录不为 null 这时使用 CAS 将 Mark Word 的值恢复给对象头<ul>
<li>成功，则解锁成功</li>
<li>失败，轻量级锁进行了锁膨胀升级成了重量级锁，进入重量级锁的解锁流程</li>
</ul>
</li>
</ul>
<p><img src="/images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png"></p>
]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>sychronized</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/04/01/test/</url>
    <content><![CDATA[<p><img src="http://heucommunity.club/%E5%81%8F%E5%90%91%E9%94%81.png"></p>
]]></content>
  </entry>
</search>
