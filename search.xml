<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap源码阅读</title>
    <url>/2022/03/27/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="HashMap-源码阅读"><a href="#HashMap-源码阅读" class="headerlink" title="HashMap 源码阅读"></a>HashMap 源码阅读</h1><h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，实现了基于哈希表的 Map 接口，非线程安全。</p>
<p>HashMap 可以存放 null 的 key 和 null 值，但 null 作为 key 只能有一个，null 作为 value 可以有多个。</p>
<p>HashMap 有两个版本：</p>
<ul>
<li>JDK8之前，HashMap 的底层数据结构为数组 + 链表，数组是 HashMap 的主体，链表则是为解决哈希冲突而存在的。</li>
<li>JDK8之后，HashMap 的底层数据结构为数组 + 链表&#x2F;红黑树，当链表长度大于阈值（默认是8）并且数组容量大于64时，将链表转换为红黑树，以减少搜索时间。</li>
</ul>
<p>HashMap 的默认大小为16，之后每次扩充，容量都变为原来的2倍，并且 HashMap 总是以2的幂作为哈希表的大小</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>loadFactor</code>被称为负载因子，其默认大小为0.75f</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="关于负载因子"><a href="#关于负载因子" class="headerlink" title="关于负载因子"></a>关于负载因子</h2><p>在分析构造函数时，我们提到了负载因子的默认大小为0.75，所以为什么为0.75，而不是1或者0.5呢？</p>
<p>首先要知道 loadFactor 的作用：</p>
<p>loadFactor 负载因子用来控制数组存放数据的疏密程度</p>
<ul>
<li><p>负载因子越大（越趋近于1），那么数组存放的数据也就越多，链表长度就会增加，<strong>会导致查找开销大，效率低</strong>。</p>
</li>
<li><p>负载因子越小（越趋近于0），那么数组存放的数据也就越少，存放数据很分散，<strong>导致数组利用率低，会频繁扩容非常消耗性能</strong>。</p>
</li>
</ul>
<blockquote>
<p>loadFactor 与 threshold</p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</blockquote>
<p>作为一般规则，默认负载因子 (.75) 在时间和空间成本之间提供了良好的折衷。较高的值会减少空间开销，但会增加查找成本（反映在 HashMap 类的大多数操作中，包括 get 和 put）。在设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以尽量减少重新哈希操作的次数。如果初始容量大于最大条目数除以负载因子，则不会发生重新哈希操作。</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="putMapEntries-方法："><a href="#putMapEntries-方法：" class="headerlink" title="putMapEntries 方法："></a><strong>putMapEntries 方法：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h3><p>HashMap 对外只提供put() 方法用于添加元素，put() 方法内部调用的是putVal() 方法</p>
<p><strong>putVal() 方法的流程如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素就直接插入</li>
<li>如果定位到的数组位置有元素就和要插入的 key 作比较，如果 key 相同就直接覆盖，如果 key 不同，就判断p是否为一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入，如果是链表节点，则遍历到链表尾部插入。</li>
</ol>
<p><img src="https://codingroad.club/put%E6%B5%81%E7%A8%8B.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//hash(key)：获取key的hash值，当key为null时，哈希值为0</span></span><br><span class="line">    <span class="comment">//key，value：要存储的键值对</span></span><br><span class="line">    <span class="comment">//第四个参数为onlyIfAbsent，默认是false，如果是true表示，如果不存在改key就进行put操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// （第一次put操作）table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="comment">//第一次resize()扩容操作后，数组容量会初始化为16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; </span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中</span></span><br><span class="line">    <span class="comment">// 桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e为辅助节点，用来记录key值与新插入节点相同的旧节点</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值相等，key不相等；</span></span><br><span class="line">        <span class="comment">// 为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JDK7的 put( ) 方法</strong></p>
<ul>
<li><p>如果定位到的数组位置没有元素 就直接插入。</p>
</li>
<li><p>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</p>
</li>
</ul>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get( ) 方法"></a>get( ) 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize( ) 方法"></a>resize( ) 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//旧数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//旧数组阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//新数组的容量和阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="comment">// MAXIMUM_CAPACITY = 1&lt;&lt;30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，容量和阈值都扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//oldCap = 0  未初始化</span></span><br><span class="line">    <span class="comment">//当使用new HashMap&lt;&gt;(int initalCapacity)时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//当使用new HashMap&lt;&gt;()时</span></span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果为初始化数组，那么到这里已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//当该数组下标j位置只有一个元素时，直接迁移这个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//计算此元素在新数组的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果e为红黑树节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//红黑树节点迁移</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//e为链表节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="comment">// 不需要换桶</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 需要换桶</span></span><br><span class="line">                        <span class="comment">// 新桶位置 = 旧桶位置+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2022/04/12/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><h2 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h2><h3 id="AOF-日志是如何实现的"><a href="#AOF-日志是如何实现的" class="headerlink" title="AOF 日志是如何实现的"></a>AOF 日志是如何实现的</h3><p>提到数据库日志，我们很容易想到 MySQL 的写前日志（WAL），也就是在实际写数据之前先把它写到日志中，以便故障时进行恢复。但是对于 Redis 的 AOF 日志来说，恰好是相反的，AOF 日志是写后日志，也就是<strong>先执行命令，把数据写入内存，再写日志</strong>。</p>
<p><img src="https://codingroad.club/20220412160054.png"> </p>
<p><strong>AOF 为什么要先执行命令写内存再写日志呢？</strong></p>
<p>我们知道传统的数据库的日志如 MySQL 的 redo log，它记录的是修改后的数据，而 AOF 记录的是 <strong>Redis 的一条条命令</strong>，这些命令以文本的形式保存，<strong>为了避免额外的检查开销，Redis 在向 AOF 里写日志的时候，并不会对指令进行语法检查</strong>，假设我们先写日志，那么如果我们输入了一条有语法错误的命令，那么这条命令也会被写进日志中，在日后恢复数据时就会产生错误。</p>
<h3 id="使用-AOF-存在的两个风险"><a href="#使用-AOF-存在的两个风险" class="headerlink" title="使用 AOF 存在的两个风险"></a>使用 AOF 存在的两个风险</h3><ol>
<li>如果刚执行完一个命令，还没来得及记日志就宕机了，那么这个命令和相应的数据就会有丢失的风险</li>
<li>虽然 AOF 避免了对当前命令的阻塞，但是也可能给下一个操作带来阻塞风险。这是因为，AOF 的日志也是在主线程中执行的，如果把日志写到磁盘时，磁盘的写压力过大，就会导致下一个命令有可能阻塞。</li>
</ol>
<h3 id="AOF-的写回策略"><a href="#AOF-的写回策略" class="headerlink" title="AOF 的写回策略"></a>AOF 的写回策略</h3><p>上面提到的<strong>两个风险其实都是和 AOF 写回磁盘的时机相关</strong>的，下面就介绍一下 AOF 的写回策略：</p>
<ol>
<li><code>Always</code>：同步写回，每次执行完命令就立刻将日志写回磁盘。</li>
<li><code>EverySec</code>：每秒写回，每次命令执行完，先把日志写到日志缓冲区中，每隔一秒就把缓冲区的日志写回磁盘中。</li>
<li><code>No</code>：操作系统控制的写回，每个命令执行完，先写到缓冲区，由操作系统决定写回磁盘的时机。</li>
</ol>
<p><img src="https://codingroad.club/20220412163814.png"></p>
<p>如何选择写回策略：</p>
<p>如果追求 “高性能” 那么就选择不做持久化或者选择设置操作系统控制的写回</p>
<p>如过追求 “高可靠” 那么就选择同步写回</p>
<p>如果允许数据丢失一点点但是，又希望性能别太受影响，那么就选择吗，每秒写回</p>
<h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><blockquote>
<p>AOF 日志是追加写的，随着接收的命令越多，AOF 日志文件也就越大，也就会带来一些性能问题。</p>
</blockquote>
<p>为了解决 AOF 日志文件过大， Redis 提供了 AOF 日志的重写机制，<strong>简单来说，AOF 的重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后为每一对键值对写入一条它的写入命令。</strong></p>
<p><strong>“一个拷贝，两个日志”</strong></p>
<p>AOF 的重写不会阻塞主线程，它是<strong>通过主线程 fork 出后台的 bgrewriteaof 子进程，此时 fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据</strong>。</p>
<p>因为 AOF 进行重写的时候主线程不会阻塞，所以主线程依然在执行客户端命令，如果这时候有写操作来了，<strong>第一个日志指的是正在使用的 AOF 日志，Redis 会把这个写操作写到它的缓冲区（即使宕机了，这个 AOF 日志操作仍然是齐全的），第二处日志是指新的 AOF 重写日志，这个操作也会被写到新的 AOF 日志的缓冲区中，等到所有的数据拷贝完，重写日志记录的这些新操作也会被写入新的 AOF 日志。</strong></p>
<p><img src="https://codingroad.club/20220412165946.png"></p>
<h2 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h2><h3 id="什么是-RDB"><a href="#什么是-RDB" class="headerlink" title="什么是 RDB"></a>什么是 RDB</h3><p>对于 Redis 来说，它实现类似照片记录效果的方式，就是把某一刻的状态以文件的形式写到磁盘上，也就是快照。与 AOF 相比 RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读如内存，很快的完成恢复。</p>
<h3 id="给哪些内存数据做快照"><a href="#给哪些内存数据做快照" class="headerlink" title="给哪些内存数据做快照"></a>给哪些内存数据做快照</h3><p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，Redis 执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘上。</p>
<p><strong>Redis 提供了两个命令来生成 RDB 文件：</strong></p>
<ol>
<li><code>save</code>：在主线程中执行，会导致阻塞。</li>
<li><code>bgsave</code>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞（默认配置）</li>
</ol>
<h3 id="快照时数据能修改吗（写时复制技术）"><a href="#快照时数据能修改吗（写时复制技术）" class="headerlink" title="快照时数据能修改吗（写时复制技术）"></a>快照时数据能修改吗（写时复制技术）</h3><p>简单来说，bgsave 子进程是由主线程 fork 出来的，可以共享主线程的所有内存数据，bgsave 子进程开始运行后，开始读取主线程的内存数据，将他们写入 RDB 文件。</p>
<p>此时，<strong>如果主线程对这些数据也有一些读操作，那么主线程和 bgsave 子进程互不影响</strong>，但是<strong>如果主线程要修改一块数据，这块数据就会被复制一份，生成该数据的副本，然后 bgsave 子进程会把这个副本写入 RDB 文件</strong>，而在这个过程中，主线程仍然可以修改原来的数据。</p>
<p><img src="https://codingroad.club/20220412185312.png"></p>
<h3 id="什么时候做快照？"><a href="#什么时候做快照？" class="headerlink" title="什么时候做快照？"></a>什么时候做快照？</h3><p>虽然 bgsave 不会阻塞主线程，但是频繁的执行全量快照，也会带来一下开销</p>
<blockquote>
<p>一方面，频繁的将全量数据写入磁盘，会给磁盘带来很大的压力，多个快照竞争有限的磁盘带宽，前一个快照还没做完，后一个又开始，容易造成恶心竞争。</p>
<p>另一方面，bgsave 子进程是通过 fork 操作从主线程中创建出来的，虽然子进程创建后不会阻塞主线程，但是 fork 这个过程是需要阻塞主线程的，频繁的执行 fork 出子进程就会频繁的阻塞主线程。 </p>
</blockquote>
<p><strong>增量快照：做了一次快照后，后续的快照只对修改的数据进行快照记录</strong></p>
<p><img src="https://codingroad.club/20220412190434.png"></p>
<h2 id="混合使用-RDB-和-AOF"><a href="#混合使用-RDB-和-AOF" class="headerlink" title="混合使用 RDB 和 AOF"></a>混合使用 RDB 和 AOF</h2><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 数据结构</title>
    <url>/2022/04/01/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis-底层数据结构"><a href="#Redis-底层数据结构" class="headerlink" title="Redis 底层数据结构"></a>Redis 底层数据结构</h1><p><img src="https://codingroad.club/20220412192031.png"></p>
<h2 id="Redis-的键和值用什么结构组织的呢？"><a href="#Redis-的键和值用什么结构组织的呢？" class="headerlink" title="Redis 的键和值用什么结构组织的呢？"></a>Redis 的键和值用什么结构组织的呢？</h2><p>为了实现键和值的快速访问，Redis 采用了一个哈希表来存储所有的键值对。一个哈希表就是一个数组，数组的每个元素称为一个哈希桶。哈<strong>希桶中保存的并不是数据本身，而是指向具体值的指针</strong>。所以不管是 String 还是集合，哈希桶的元素都是指向他们的指针。</p>
<p><img src="https://codingroad.club/20220412192049.png"></p>
<h2 id="Redis-的-rehash操作"><a href="#Redis-的-rehash操作" class="headerlink" title="Redis 的 rehash操作"></a>Redis 的 rehash操作</h2><p>虽然 Redis 使用拉链法解决哈希冲突，但是随着哈希冲突越来越多，会导致拉链过长，进而导致这条链上的元素过多，增加查找耗时。所以 Redis 会对哈希表进行 rehash 操作来增加现有的哈希桶的数量。</p>
<p>为了使 rehash 操作更高效，redis 使用了两个全局哈希表，一开始插入数据时，只向哈希表1插入数据，对哈希表2不做操作，，随着数据不断增多，Redis 开始执行 rehash 操作，可以分为3步：</p>
<ol>
<li>给哈希表2分配更大的空间，如哈希表1的二倍。</li>
<li>把哈希表1的数据重新映射并拷贝到哈希表2。</li>
<li>释放哈希表1的空间，留作下一次 rehash 使用。</li>
</ol>
<blockquote>
<p><strong>渐进式 rehash</strong></p>
<p>为了避免一次性拷贝大量数据造成 Redis 线程阻塞，Redis 采用渐进式 rehash</p>
<p>简单来说就是在拷贝数据时，Redis 正常处理客户端请求，每处理一个请求时，从哈希表 1 中的一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置。</p>
</blockquote>
<h2 id="集合类型的底层数据结构"><a href="#集合类型的底层数据结构" class="headerlink" title="集合类型的底层数据结构"></a>集合类型的底层数据结构</h2><p>集合类型的底层数据结构有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p><img src="https://codingroad.club/20220412192110.png"></p>
<p>压缩列表类似于数组，数组中的每一个元素都对应了一个数据，不过和数组不同的是，压缩列表在压缩列表的表头增加了三个字段：zlbytes、zltail和zllen。在列表的尾部增加了 zlend 字段。</p>
<blockquote>
<p>zlbytes：列表长度</p>
<p>zltail：列表尾的偏移量</p>
<p>zllend：列表中 entry 的数量</p>
<p>zlend：表示列表结束</p>
</blockquote>
<p>压缩列表查找列表第一个元素和最后一个元素的时间复杂度为<code>O(1)</code>，查找其他元素则为<code>O(N)</code></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表，<strong>跳表是在链表的基础上增加了多级索引，通过索引位置的几个跳转实现数据的快速定位。</strong></p>
<p><img src="https://codingroad.club/20220412192129.png"></p>
<blockquote>
<p>如果我们在链表中查找 33 这个元素，只能从头开始遍历这个链表，查找 6 次，直到可以找到 33 这个元素，时间复杂度为 <code>O(N)</code>。</p>
<p>为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就能定位到元素 33 了。</p>
<p>如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。</p>
<p>可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 <code>O(logN)</code>。</p>
</blockquote>
<h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><p><img src="https://codingroad.club/20220412192146.png"></p>
<h2 id="为什么-String-类型内存开销大"><a href="#为什么-String-类型内存开销大" class="headerlink" title="为什么 String 类型内存开销大"></a>为什么 String 类型内存开销大</h2><p>String 类型除了记录实际数据外，还需要额外的内存空间记录数据长度、空间使用等信息，这些信息叫做元数据。</p>
<h3 id="简单动态字符串-SDS-（Simple-Dynamic-String）"><a href="#简单动态字符串-SDS-（Simple-Dynamic-String）" class="headerlink" title="简单动态字符串 SDS （Simple Dynamic String）"></a>简单动态字符串 SDS （Simple Dynamic String）</h3><p>当 String 类型保存的数据为字符时，String 就会用 SDS 结构体来保存数据。</p>
<img src="https://codingroad.club/20220412192203.png" style="zoom:50%;" />

<blockquote>
<p><strong>buf</strong>：字节数组，保存实际数据。为了表示字节数组的结束，在数组最后加上<code>\0</code>表示数组结束，占用一个字节</p>
<p><strong>len：</strong>占4个字节，表示 buf 的已用长度。</p>
<p><strong>alloc：</strong>占4个字节，表示 buf 的实际分配长度，一般大于 len</p>
</blockquote>
<h3 id="RedisObject-结构体"><a href="#RedisObject-结构体" class="headerlink" title="RedisObject 结构体"></a>RedisObject 结构体</h3><p>redis 的数据类型有很多，而且，不同的数据类型有些相同的元数据要记录（比如说最后一次访问的时间、被引用的次数等），因此 Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p>
<img src="https://codingroad.club/20220412192221.png" style="zoom:50%;" />

<h3 id="String-类型是怎么保存数据的呢？"><a href="#String-类型是怎么保存数据的呢？" class="headerlink" title="String 类型是怎么保存数据的呢？"></a>String 类型是怎么保存数据的呢？</h3><p>三种编码方式：</p>
<ol>
<li>当保存64位有符号整数时，<strong>String 类型会把它保存为一个 8 字节的 Long 类型的整数</strong>，这种保存方式通常叫做 int 编码方式</li>
<li>当保存的是字符串数据，并且字符串小<strong>于等于44字节</strong>的时候，<strong>RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域</strong>，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式。</li>
<li>当字符串<strong>大于 44 字节</strong>的时候，SDS 数据量就开始变多，Redis 就不再把 RedisObject 和 SDS 放在一起了，而是<strong>会给 SDS 分配独立的内存区域，并用指针指向 SDS 结构</strong>。这种布局方式被称为 raw 编码模式。</li>
</ol>
<p><img src="https://codingroad.club/20220412192241.png"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>sychronized原理</title>
    <url>/2022/03/27/sychronized%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p>我们先来看一下什么是 Monitor ？</p>
<p>Monitor 被翻译成<strong>监视器</strong>或<strong>管程</strong>，每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁，那么该对象头的Mark Word 就被设置指向 Monitor 对象的指针。 </p>
<p>Monitor 的结构如下：</p>
<p><img src="https://codingroad.club/Monitor%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>刚开始 Monitor 的 Owner 为null</li>
<li>当 Thread-2 执行 sychronized(Obj) 时，Monitor 的 Owner 会设置为 Thread-2，Monitor 中只能有一个 Owner</li>
<li>在 Thread-2 上锁过程中，如果其他线程也来获取这个对象锁，就会进入 EntryList 阻塞</li>
<li>当 Thread-2 执行完同步代码块后，会唤醒 EntryList 中的线程来竞争锁，非公平竞争</li>
<li>WaitSet 中的 Thread-0 和 Thread-1 是之前获得过锁。</li>
</ul>
<h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h2><p>synchronized 加在<strong>同步代码</strong>块和加在<strong>方法</strong>上的原理是有一些不同的。</p>
<h3 id="同步代码块上的-synchronized"><a href="#同步代码块上的-synchronized" class="headerlink" title="同步代码块上的 synchronized"></a>同步代码块上的 synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syn</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v</code>反编译之后的字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synDemo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  </span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span>                 </span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1               </span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="number">11</span>: monitorenter           <span class="comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span></span><br><span class="line">        <span class="number">12</span>: getstatic     #<span class="number">3</span>      </span><br><span class="line">        <span class="number">15</span>: invokestatic  #<span class="number">4</span>      </span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">5</span>      </span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>      </span><br><span class="line">        <span class="number">24</span>: aload_2</span><br><span class="line">        <span class="number">25</span>: monitorexit            <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">        <span class="number">26</span>: goto          <span class="number">34</span></span><br><span class="line">        <span class="number">29</span>: astore_3</span><br><span class="line">        <span class="number">30</span>: aload_2</span><br><span class="line">        <span class="number">31</span>: monitorexit            <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">        <span class="number">32</span>: aload_3</span><br><span class="line">        <span class="number">33</span>: athrow</span><br><span class="line">        <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">12</span>    <span class="number">26</span>    <span class="number">29</span>   any</span><br><span class="line">            <span class="number">29</span>    <span class="number">32</span>    <span class="number">29</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">34</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">35</span>     <span class="number">0</span>  <span class="built_in">this</span>   LsychronizedDemo/Syn;</span><br><span class="line">            <span class="number">8</span>      <span class="number">27</span>     <span class="number">1</span>     o   Ljava/lang/Object;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">29</span></span><br><span class="line">          locals = [ <span class="keyword">class</span> <span class="title class_">sychronizedDemo</span>/Syn, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">23</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过字节码文件我们可以看到，sychronized 加在同步代码块上是通过两个指令，<code>monitorenter</code> 和 <code>monitorexit</code> 实现的。</p>
<p>每个对象都有一个 Monitor ，当 Monitor 被占用时就表示对象处于锁定状态，<code>monitorenter</code>指令就是来获取 Monitor 的所有权，<code>monitorexit</code>指令就是释放 Monitor 的所有权。这两者的工作流程如下：<br><strong>monitorenter</strong>：</p>
<ol>
<li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li>
<li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li>
<li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，直到<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li>
</ol>
<p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p>
<h3 id="同步方法上的synchronized"><a href="#同步方法上的synchronized" class="headerlink" title="同步方法上的synchronized"></a>同步方法上的synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synDemo1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v</code>反编译之后的字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synDemo1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>               </span><br><span class="line">         <span class="number">3</span>: invokestatic  #<span class="number">4</span>                 </span><br><span class="line">         <span class="number">6</span>: invokevirtual #<span class="number">5</span>                 </span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">6</span>                  </span><br><span class="line">        <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">12</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  <span class="built_in">this</span>   LsychronizedDemo/Syn;</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">23</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从字节码文件中可以看到，同步方法上的 synchronized 并没有使用<code>monitorenter</code>和<code>monitorexit</code>指令，而是在常量池中比普通方法多了<code>ACC_SYNCHRONIZED</code>标识，JVM 就根据这个标识来实现方法的同步。</p>
<p>当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p>
<h3 id="两种同步方式的区别"><a href="#两种同步方式的区别" class="headerlink" title="两种同步方式的区别"></a>两种同步方式的区别</h3><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong></p>
<p>synchronized同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。</p>
<p><strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong></p>
<h1 id="sychronized-锁优化"><a href="#sychronized-锁优化" class="headerlink" title="sychronized 锁优化"></a>sychronized 锁优化</h1><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p>
<p>对象头由以下三个部分组成：</p>
<ul>
<li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程ID、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li>
<li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li>
</ul>
<h2 id="synchronized-优化"><a href="#synchronized-优化" class="headerlink" title="synchronized 优化"></a>synchronized 优化</h2><p>上文说的 synchronized 锁原理其实说的都是<strong>重量级锁</strong>的原理那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？其实是<strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>。当锁的状态为其他状态的时候是没有用上Monitor对象的。</p>
<p>锁膨胀方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且膨胀方向不可逆。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，<strong>之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS</strong>。以后只要不发生竞争，这个对象就归该线程所有</p>
<h3 id="自旋与适应性自旋"><a href="#自旋与适应性自旋" class="headerlink" title="自旋与适应性自旋"></a>自旋与适应性自旋</h3><p><strong>自旋</strong>：当一个线程取请求某个锁的时候，这个锁正在被其他线程占用，这时此线程不会立刻进入阻塞，而是循环请求锁（自旋），<strong>自旋的目的是因为很多情况下持有锁的线程很快会释放锁，线程可以尝试一直请求锁，所以线程没有必要放弃cpu时间片，因为线程被挂起再唤醒的开销是比较大的</strong>。当然如果线程自旋一定时间还没有获得锁，仍然会被挂起。</p>
<p><strong>适应性自旋</strong>：自适应自旋是对自旋的优化，自选的时间不再固定，而是<strong>由前一次在同一个锁上的自旋时间和当前拥有锁的线程的状态决定的</strong>。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。比如下面method1经过锁粗化优化之后就和method2执行效率一样了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(test.class) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Systom.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。比如下面代码的method3和method4的执行效率是一样的，因为object锁是私有变量，不存在所得竞争关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    sychronized(obj) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methord4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁-1"><a href="#偏向锁-1" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>一句话总结它的作用：<strong>减少同一线程获取锁的代价</strong>。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。</p>
<p><strong>核心思想：</strong></p>
<p>如果一个线程获得了锁，那么锁就进入偏向模式，此时<code>Mark Word</code>的结构也就变为偏向锁结构，<strong>当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查</strong><code>Mark Word</code><strong>的锁标记位为偏向锁以及当前线程ID等于</strong><code>Mark Word</code><strong>的ThreadID即可</strong>，这样就省去了大量有关锁申请的操作</p>
<p><img src="https://codingroad.club/%E5%81%8F%E5%90%91%E9%94%81.png"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>应用场景：如果一个对象有多线程要加锁，但是加锁时间是错开始（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<ul>
<li>创建锁记录（Lock Record）对象，每个线程的栈帧都会包含锁记录的结构，内部可以存储锁定对象的Mark Word</li>
<li>让锁记录中的 Object Referrence 指向锁对象，并尝试 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>
<li>如果 CAS 成功，那么对象头中存储了<code>锁记录地址和状态00</code>，表示由该线程给对象加锁。  </li>
<li>如果 CAS 失败，有两种情况<ul>
<li>如果其他线程已经持有了 Object 的轻量级锁，表明有竞争，进入锁膨胀</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
<li>退出 synchronized 代码块的时候，如果锁记录为 null 则表示有锁重入，这时重置锁记录，表示重入计数减一</li>
<li>当退出 synchronized 代码块的时候锁记录不为 null 这时使用 CAS 将 Mark Word 的值恢复给对象头<ul>
<li>成功，则解锁成功</li>
<li>失败，轻量级锁进行了锁膨胀升级成了重量级锁，进入重量级锁的解锁流程</li>
</ul>
</li>
</ul>
<p><img src="https://codingroad.club/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png"></p>
]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>sychronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis作为缓存</title>
    <url>/2022/04/12/Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Redis-作为缓存要知道的那些事儿"><a href="#Redis-作为缓存要知道的那些事儿" class="headerlink" title="Redis 作为缓存要知道的那些事儿"></a>Redis 作为缓存要知道的那些事儿</h1><h2 id="Redis-作为缓存是如何工作的"><a href="#Redis-作为缓存是如何工作的" class="headerlink" title="Redis 作为缓存是如何工作的"></a>Redis 作为缓存是如何工作的</h2><h3 id="缓存的特征"><a href="#缓存的特征" class="headerlink" title="缓存的特征"></a>缓存的特征</h3><ol>
<li>在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis 就是快速子系统，而数据库就是慢速子系统了。</li>
<li>缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。</li>
</ol>
<h3 id="Redis-缓存处理请求的两种情况"><a href="#Redis-缓存处理请求的两种情况" class="headerlink" title="Redis 缓存处理请求的两种情况"></a>Redis 缓存处理请求的两种情况</h3><p><strong>缓存命中：</strong>Redis 中有相应的数据，就直接读取 Redis，性能非常快。</p>
<p><strong>缓存缺失：</strong>Redis 中没有保存相应的数据，就从后端数据库中读取相应的数据，性能就会变慢。</p>
<h3 id="Redis-作为旁路缓存的使用操作"><a href="#Redis-作为旁路缓存的使用操作" class="headerlink" title="Redis 作为旁路缓存的使用操作"></a>Redis 作为旁路缓存的使用操作</h3><p>我们把 Redis 称为旁路缓存是因为读取缓存、读取数据库和更新缓存的操作都需要在应用程序中完成。</p>
<p>使用 Redis 缓存时，我们需要在应用程序中增加 3 方面的代码：</p>
<blockquote>
<ul>
<li>当应用程序需要读取数据时，我们需要在代码中显式调用 Redis 的 GET 操作接口，进行查询；</li>
<li>如果缓存缺失了，应用程序需要再和数据库连接，从数据库中读取数据；</li>
<li>当缓存中的数据需要更新时，我们也需要在应用程序中显式地调用 SET 操作接口，把更新的数据写入缓存。</li>
</ul>
</blockquote>
<p>在使用旁路缓存时，我们需要应用程序中增加操作代码，增加了使用 Redis 缓存的额外工作量，但是，也正因为 Redis 是旁路缓存，是一个独立的系统，我们可以单独对 Redis 缓存进行扩容和性能优化。</p>
<h3 id="缓存的类型"><a href="#缓存的类型" class="headerlink" title="缓存的类型"></a>缓存的类型</h3><ul>
<li>只读缓存：先读 Redis 缓存，命中则直接返回，未命中读取后端数据库，并同时将数据存入缓存；写请求直接发给后端数据库，在数据库中增删改，对于删改的数据来说，如果 Redis 已经缓存了，则将其删除。</li>
<li>读写缓存：所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。此时，得益于Redis 的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。根据业务应用对数据可靠性和缓存性能的不同要求，我们会有<strong>同步直写和异步写回</strong>两种策略。其中，<strong>同步直写策略优先保证数据可靠性，而异步写回策略优先提供快速响应</strong>。</li>
</ul>
<h2 id="缓存满了怎么办"><a href="#缓存满了怎么办" class="headerlink" title="缓存满了怎么办"></a>缓存满了怎么办</h2><h3 id="Redis-缓存的淘汰策略"><a href="#Redis-缓存的淘汰策略" class="headerlink" title="Redis 缓存的淘汰策略"></a>Redis 缓存的淘汰策略</h3><p>Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。</p>
<blockquote>
<p>noeviction：不进行数据淘汰的策略（Redis 的默认设置）</p>
<p>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis 4.0 后新增）四种。</p>
<p>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis4.0 后新增）三种。</p>
</blockquote>
<p><img src="https://codingroad.club/Snipaste_2022-03-23_18-28-14.png"></p>
<p>设置过期时间：</p>
<ul>
<li>volatile-ttl：会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除</li>
<li>volatile-random：针对设置了过期时间的键值对，随机选择删除</li>
<li>volatile-lru：针对设置了过期时间的键值对，根据 LRU（最近最少使用）算法进行淘汰</li>
<li>volatile-lfu：针对设置了过期时间的键值对，根据 LFR（最不经常使用）算法进行淘汰</li>
</ul>
<p>未设置过期时间：</p>
<ul>
<li>allkeys-random：从所有键值对中随机选择并删除</li>
<li>allkeys-lru：从所有键值对中根据 LRU（最近最少使用）算法进行淘汰</li>
<li>allkeys-lfu：从所有的键值对中根据 LFR（最不经常使用）算法进行淘汰</li>
</ul>
<h3 id="如何处理被淘汰的数据？"><a href="#如何处理被淘汰的数据？" class="headerlink" title="如何处理被淘汰的数据？"></a>如何处理被淘汰的数据？</h3><p><strong>一般情况下</strong>，一旦淘汰的数据选定后，如果这个数据是干净数据，那么直接删除；如果是脏数据则需要写回数据库。而<strong>对于 Redis 来说</strong>，它决定了被淘汰的数据后，会把它们删除。即使淘汰的数据是脏数据，Redis 也不会把它们写回数据库。所以，我们在使用 Redis 缓存时，如果数据被修改了，需要在数据修改时就将它写回数据库。否则，这个脏数据被淘汰时，会被 Redis 删除，而数据库里也没有最新的数据了</p>
<h2 id="如何解决缓存和数据库数据不一致问题？"><a href="#如何解决缓存和数据库数据不一致问题？" class="headerlink" title="如何解决缓存和数据库数据不一致问题？"></a>如何解决缓存和数据库数据不一致问题？</h2><h3 id="缓存和数据库的数据不一致是如何发生的？"><a href="#缓存和数据库的数据不一致是如何发生的？" class="headerlink" title="缓存和数据库的数据不一致是如何发生的？"></a>缓存和数据库的数据不一致是如何发生的？</h3><p><img src="https://codingroad.club/Snipaste_2022-03-23_18-56-20.png"></p>
<h3 id="如何解决数据库不一致问题？"><a href="#如何解决数据库不一致问题？" class="headerlink" title="如何解决数据库不一致问题？"></a>如何解决数据库不一致问题？</h3><h4 id="先删缓存后更新数据库"><a href="#先删缓存后更新数据库" class="headerlink" title="先删缓存后更新数据库"></a>先删缓存后更新数据库</h4><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p><img src="https://codingroad.club/Snipaste_2022-03-23_19-13-07.png"></p>
<p><strong>答案一：延时双删</strong></p>
<p><strong>在线程 A 更新完数据库以后，可以让它 sleep 一段时间，再进行一次缓存删除。</strong></p>
<blockquote>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。</p>
</blockquote>
<p><strong>答案二：更新与读取操作进行异步串行化</strong></p>
<p><strong>异步串行化</strong></p>
<p>在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同    ·一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。</p>
<p>这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。</p>
<p><strong>读操作去重</strong></p>
<p>多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）</p>
<h4 id="先更新数据库在删除缓存"><a href="#先更新数据库在删除缓存" class="headerlink" title="先更新数据库在删除缓存"></a>先更新数据库在删除缓存</h4><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>
<p><img src="https://codingroad.club/20220412193640.png"></p>
<p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p>
<ol>
<li>请求 A 先对数据库进行更新操作</li>
<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>
<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>
<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>
</ol>
<p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>
<h4 id="关于解决数据库不一致问题的总结"><a href="#关于解决数据库不一致问题的总结" class="headerlink" title="关于解决数据库不一致问题的总结"></a>关于解决数据库不一致问题的总结</h4><p>删除缓存值或更新数据库失败而导致数据不一致，你可以使用消息队列机制确保删除或更新操作成功。</p>
<p>在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删或者更新与读取操作进行异步串行化。</p>
<h2 id="如何解决缓存雪崩、击穿、穿透难题？"><a href="#如何解决缓存雪崩、击穿、穿透难题？" class="headerlink" title="如何解决缓存雪崩、击穿、穿透难题？"></a>如何解决缓存雪崩、击穿、穿透难题？</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指<strong>大量的应用请求无法在 Redis 缓存中处理，造成大量请求发送到数据库，导致数据库压力激增</strong>。</p>
<p>造成缓存雪崩一般又两个原因导致：</p>
<ol>
<li><p>缓存中有大量的 key 同时过期，导致大量请求无法处理</p>
</li>
<li><p>Redis 缓存实例发生故障宕机无法处理请求</p>
</li>
</ol>
<p>解决方案：</p>
<p>1、事前：</p>
<ul>
<li><p><strong>均匀过期</strong>：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个Key的失效时间都加个随机值，<code>setRedis（Key，value，time + Math.random() * 10000）；</code>，保证数据不会在同一时间大面积失效。</p>
</li>
<li><p><strong>分级缓存</strong>：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</p>
</li>
<li><p><strong>热点数据缓存永远不过期</strong>。永不过期实际包含两层意思：</p>
<ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>
</ul>
</li>
<li><p><strong>保证Redis缓存的高可用</strong>，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</p>
</li>
</ul>
<p>2、事中：</p>
<ul>
<li><p><strong>互斥锁</strong>：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p>
</li>
<li><p><strong>使用熔断机制，限流降级</strong>。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</p>
</li>
</ul>
<p>3、事后：</p>
<p><strong>开启Redis持久化机制，尽快恢复缓存数据</strong>，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p>
<p>从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p>
<p>解决方案：</p>
<ul>
<li><p><strong>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量</strong>，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p>
</li>
<li><p><strong>热点数据缓存永远不过期</strong>。永不过期实际包含两层意思：</p>
<ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<p><img src="https://codingroad.club/20220412193708.png"></p>
<p>解决方法：</p>
<ul>
<li>将无效的key存放进Redis中：</li>
</ul>
<p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value&#x3D;”null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</p>
<ul>
<li>使用布隆过滤器：</li>
</ul>
<p>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们<strong>可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在</strong>，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<blockquote>
<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
